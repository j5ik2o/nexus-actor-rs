> 現状把握

- Rust版 remote クレートは gRPC サーバ起動・アドレス解決の登録・エンドポイント管理など、リモート通信の骨格は既に実装されています。Remote::start で gRPC サーバを立ち上げ ProcessRegistry にアドレスリゾルバを登録し
  (remote/src/remote.rs:124)、EndpointManager や EndpointWatcher がリモート監視／Terminate 通知を担っています (remote/src/endpoint_manager.rs:196, remote/src/endpoint_watcher.rs:1)。
- メッセージ配送は EndpointWriter でバッチ化され、RemoteDeliver を MessageBatch に変換して送信する流れも Go 版に近い形で用意されています (remote/src/endpoint_writer.rs:200)。

protoactor-go と比べて未整備な点

- 双方向ストリームの片側未実装: gRPC 受信側で ClientConnection 分岐が TODO のまま残っており、ピアがクライアントとして接続してくるケースを処理できません (remote/src/endpoint_reader.rs:60-66)。Go 版ではサーバ・クラ
  イアントの両方向ストリームを扱っています。citeturn12open0
- リモート診断 RPC が未実装: ListProcesses と GetProcessDiagnostics が常に UNIMPLEMENTED を返す stub のままです (remote/src/endpoint_reader.rs:379-387)。Go 版は同名 RPC を公開してリモートプロセス情報を取得できるよ
  うにしており、ドキュメントにも診断 API の利用例が記載されています。citeturn12open0
- 接続設定の拡張性: Rust 版の ConfigOption はホスト・ポート・アドレス・Kind 登録のみをサポートしており (remote/src/config_option.rs:5-44)、TLS や gRPC Dial/Call オプションを指定する仕組みがありません。protoactor-
  go では remote.WithDialOptions / WithCallOptions / WithServerOptions などのビルダーが用意されており、トランスポートレイヤーを柔軟に設定できます。citeturn12open0
- ブロックリスト API の未統合: BlockList 自体は CRUD を備えていますが (remote/src/block_list.rs:9-45)、リモート起動フローからこれらを呼び出す公開 API がなく、runtime 中にノードをブロック／アンブロックする導線があ
  りません。Go 版はリモート設定経由でブラックリストを操作できるため、運用面で差があります。citeturn12open0
- テレメトリ／監視系の差分: Go 版は EventStream 連携やリトライ・ヘルスチェックを含む多くの実戦機能が整備されていますが、Rust 版は EndpointWriter の再接続や DeadLetter ハンドリングが最小限で、メトリクス／監視連携の
  フックもまだ提供されていません (例: EndpointWriter がシリアライズ失敗をログ出力のみで処理している remote/src/endpoint_writer.rs:238)。citeturn12open0

まとめ

- Rust 実装は「Actor のリモート配達・リモート監視・Activator によるリモート Spawn」といった基本要素は揃っているものの、protoactor-go が備えるリモート診断、双方向ストリーム、豊富な接続オプション、運用向け API まで
  は追いついていません。
- 互換性を高めるには、ClientConnection 経路や診断 RPC の実装、Config まわりのオプション拡充、BlockList 操作用の公開 API 追加などが優先的な差分になります。
- 逆に言えば、コアとなる RemoteDeliver 〜 EndpointManager の流れは既に Rust らしい async 実装に落とし込まれているため、足りない部分を段階的に埋めれば protoactor-go と同等レベルまで拡張しやすい状態です。