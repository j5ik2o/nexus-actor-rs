概況

- remote クレートは Remote／EndpointManager／EndpointReader／EndpointWriter といった主要コンポーネントを Rust イディオムで移植しており、基本的な接続・メッセージ配送経路は protoactor-go の構造を追従しています。Remote::register や PID のアドレスリゾルバ追加など司令塔部分
  は概ね揃っており、tonic ベースで gRPC サーバを立ち上げるループも動きます (remote/src/remote.rs:40-190)。

主な差異・懸念点

- クラスタ系メッセージのシリアライズ適用が未実装です。RootSerializable／RootSerialized を担う箇所が todo!() のままなので、PubSub や DeliverBatch 系のバイナリアップキャストが機能しません (remote/src/cluster/messages.rs:23-76)。protoactor-go ではここがデリバリーパスの肝に
  なっているため、クラスタ連携機能はまだ動かせません。
- EndpointWriter のリトライ処理にバグがあります。一度失敗して error = Some(..) が入ったあと成功しても error を None に戻さないため、最終的に常に EndpointTerminatedEvent を発行してしまいます (remote/src/endpoint_writer.rs:105-135)。go 実装は err をループごとに代入し直す
  のでこうした誤判定は発生しません (docs/sources/protoactor-go/remote/endpoint_writer.go:16-70)。
- メールボックスがバッチ化されておらず batch_size が実質死んでいます。poll_user_mailbox で poll_many を呼ぶべき部分がコメントアウトされ単件処理になっており、Go 側の PopMany によるバッチ送信と乖離しています (remote/src/endpoint_writer_mailbox.rs:64-68, docs/sources/
  protoactor-go/remote/endpoint_writer_mailbox.go:61-92)。
- EndpointSupervisor 生成時に dispatcher 指定などが未移植で // TODO: が残っています。Go 版が WithDispatcher(NewSynchronizedDispatcher(300)) を与えているのに対し、Rust 版はガーディアン／戦略のみでキューの並列度を制御できていません (remote/src/endpoint_manager.rs:245-257,
  docs/sources/protoactor-go/remote/endpoint_manager.go:73-116)。
- gRPC 補助 API は未実装のまま UNIMPLEMENTED を返しています。ListProcesses／GetProcessDiagnostics が常に Status::unimplemented なので、protoactor-go の将来機能に追従できていません (remote/src/endpoint_reader.rs:436-445)。また ClientConnection 取り扱いも TODO で、クライ
  アントタイプの接続は受けられません (remote/src/endpoint_reader.rs:59-70)。
- 構成オプションが最小限です。Go 版の WithDialOptions や WithEndpointWriterBatchSize などが Rust 版には存在せず、ConfigOption は host／port／advertised／kind 登録のみになっています (remote/src/config_option.rs:5-44, docs/sources/protoactor-go/remote/config-opts.go:7-
  53)。これではネットワーク設定や再送キュー長の調整ができません。
- ResponseStatusCode は enum 定義のみで、Go 側にある AsError 等のマッピングが欠落しています (remote/src/response_status_code.rs:5-16, docs/sources/protoactor-go/remote/response_status_code.go:1-63)。呼び出し元から原因を取り出せません。
- ログレベルが過剰に info! で固定されており、バッチ処理ごとに大量出力されるなどノイズが多いです (remote/src/endpoint_reader.rs:125-159, remote/src/endpoint_writer.rs:103-142)。Go 版は Debug／Info を用途に応じて切り替えています。

改善提案

1. RootSerializable 系の todo!() を全て実装し、DeliverBatch／PubSub 経路を通せるようにする。protoactor-go の cluster 実装を写経しつつ Rust の Arc<dyn Message> に合わせたシリアライズを設計する。
2. EndpointWriter のリトライロジックを修正し、成功時は error = None に戻す、または Result を即 return する。合わせて接続確立後の EndpointConnectedEvent 発行条件を見直す。
3. メールボックスで poll_many を復活させ、batch_size を尊重する。あわせて Props::with_dispatcher 相当を導入し、Go 側の synchronized dispatcher に近い挙動を再現する。
4. ConfigOption にキューサイズ／リトライ／DialOptions 相当の設定 API を追加し、Go 側の Config と同じ粒度でチューニングできるようにする。
5. gRPC 管理 API (ListProcesses など) と ClientConnection 処理を埋め、将来的な管理ツールとの互換性を確保する。
6. ResponseStatusCode にステータス→エラー変換ヘルパを追加し、呼び出し元が結果をハンドリングしやすくする。
7. ログ出力の粒度を調整 (trace／debug へ変更) し、稼働時のノイズを抑制する。

現状でも基本的なリモートメッセージ配送は動作しますが、protoactor-go と同等レベルまではもう少し距離があります。上記の差分を埋めれば、クラスタ連携や大量メッセージ処理の安定性が大きく向上するはずです。