// This file is @generated by prost-build.
/// request response call from Identity actor sent to each member
/// asking what activations they hold that belong to the requester
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdentityHandoverRequest {
    #[prost(message, optional, tag = "1")]
    pub current_topology: ::core::option::Option<identity_handover_request::Topology>,
    #[prost(string, tag = "2")]
    pub address: ::prost::alloc::string::String,
    /// If the requester passes a delta topology, only return activations which would not be assigned to the member
    /// in the previous topology.
    #[prost(message, optional, tag = "3")]
    pub delta_topology: ::core::option::Option<identity_handover_request::Topology>,
}
/// Nested message and enum types in `IdentityHandoverRequest`.
pub mod identity_handover_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Topology {
        #[prost(uint64, tag = "1")]
        pub topology_hash: u64,
        #[prost(message, repeated, tag = "3")]
        pub members: ::prost::alloc::vec::Vec<super::Member>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdentityHandover {
    #[prost(message, repeated, tag = "1")]
    pub actors: ::prost::alloc::vec::Vec<Activation>,
    #[prost(int32, tag = "2")]
    pub chunk_id: i32,
    #[prost(bool, tag = "3")]
    pub r#final: bool,
    #[prost(uint64, tag = "4")]
    pub topology_hash: u64,
    /// Total number of activations skipped
    #[prost(int32, tag = "5")]
    pub skipped: i32,
    /// Total number of activations sent
    #[prost(int32, tag = "6")]
    pub sent: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoteIdentityHandover {
    #[prost(message, optional, tag = "1")]
    pub actors: ::core::option::Option<PackedActivations>,
    #[prost(int32, tag = "2")]
    pub chunk_id: i32,
    #[prost(bool, tag = "3")]
    pub r#final: bool,
    #[prost(uint64, tag = "4")]
    pub topology_hash: u64,
    #[prost(int32, tag = "5")]
    pub skipped: i32,
    #[prost(int32, tag = "6")]
    pub sent: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackedActivations {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub actors: ::prost::alloc::vec::Vec<packed_activations::Kind>,
}
/// Nested message and enum types in `PackedActivations`.
pub mod packed_activations {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Kind {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "2")]
        pub activations: ::prost::alloc::vec::Vec<Activation>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Activation {
        #[prost(string, tag = "1")]
        pub identity: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub activation_id: ::prost::alloc::string::String,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IdentityHandoverAck {
    #[prost(int32, tag = "1")]
    pub chunk_id: i32,
    #[prost(uint64, tag = "2")]
    pub topology_hash: u64,
    #[prost(enumeration = "identity_handover_ack::State", tag = "3")]
    pub processing_state: i32,
}
/// Nested message and enum types in `IdentityHandoverAck`.
pub mod identity_handover_ack {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Processed = 0,
        IncorrectTopology = 1,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Processed => "processed",
                Self::IncorrectTopology => "incorrect_topology",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "processed" => Some(Self::Processed),
                "incorrect_topology" => Some(Self::IncorrectTopology),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterIdentity {
    #[prost(string, tag = "1")]
    pub identity: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub kind: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Activation {
    #[prost(message, optional, tag = "1")]
    pub pid: ::core::option::Option<super::actor::Pid>,
    #[prost(message, optional, tag = "2")]
    pub cluster_identity: ::core::option::Option<ClusterIdentity>,
}
/// Started terminating, not yet removed from IIdentityLookup
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivationTerminating {
    #[prost(message, optional, tag = "1")]
    pub pid: ::core::option::Option<super::actor::Pid>,
    #[prost(message, optional, tag = "2")]
    pub cluster_identity: ::core::option::Option<ClusterIdentity>,
}
/// Terminated, removed from lookup
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivationTerminated {
    #[prost(message, optional, tag = "1")]
    pub pid: ::core::option::Option<super::actor::Pid>,
    #[prost(message, optional, tag = "2")]
    pub cluster_identity: ::core::option::Option<ClusterIdentity>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivationRequest {
    #[prost(message, optional, tag = "1")]
    pub cluster_identity: ::core::option::Option<ClusterIdentity>,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub topology_hash: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProxyActivationRequest {
    #[prost(message, optional, tag = "1")]
    pub cluster_identity: ::core::option::Option<ClusterIdentity>,
    #[prost(message, optional, tag = "2")]
    pub replaced_activation: ::core::option::Option<super::actor::Pid>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivationResponse {
    #[prost(message, optional, tag = "1")]
    pub pid: ::core::option::Option<super::actor::Pid>,
    #[prost(bool, tag = "2")]
    pub failed: bool,
    #[prost(uint64, tag = "3")]
    pub topology_hash: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReadyForRebalance {
    #[prost(uint64, tag = "1")]
    pub topology_hash: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RebalanceCompleted {
    #[prost(uint64, tag = "1")]
    pub topology_hash: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Member {
    #[prost(string, tag = "1")]
    pub host: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub port: i32,
    #[prost(string, tag = "3")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub kinds: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterTopology {
    #[prost(uint64, tag = "1")]
    pub topology_hash: u64,
    #[prost(message, repeated, tag = "2")]
    pub members: ::prost::alloc::vec::Vec<Member>,
    #[prost(message, repeated, tag = "3")]
    pub joined: ::prost::alloc::vec::Vec<Member>,
    #[prost(message, repeated, tag = "4")]
    pub left: ::prost::alloc::vec::Vec<Member>,
    #[prost(string, repeated, tag = "5")]
    pub blocked: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterTopologyNotification {
    #[prost(string, tag = "1")]
    pub member_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub topology_hash: u32,
    #[prost(string, tag = "3")]
    pub leader_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MemberHeartbeat {
    #[prost(message, optional, tag = "1")]
    pub actor_statistics: ::core::option::Option<ActorStatistics>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorStatistics {
    #[prost(map = "string, int64", tag = "1")]
    pub actor_count: ::std::collections::HashMap<::prost::alloc::string::String, i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GrainRequest {
    #[prost(int32, tag = "1")]
    pub method_index: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub message_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "3")]
    pub message_type_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GrainResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub message_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    pub message_type_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GrainErrorResponse {
    #[prost(string, tag = "1")]
    pub reason: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Identifies a subscriber by either ClusterIdentity or PID
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscriberIdentity {
    #[prost(oneof = "subscriber_identity::Identity", tags = "1, 2")]
    pub identity: ::core::option::Option<subscriber_identity::Identity>,
}
/// Nested message and enum types in `SubscriberIdentity`.
pub mod subscriber_identity {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Identity {
        #[prost(message, tag = "1")]
        Pid(super::super::actor::Pid),
        #[prost(message, tag = "2")]
        ClusterIdentity(super::ClusterIdentity),
    }
}
/// First request to initialize the actor.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Initialize {
    #[prost(message, optional, tag = "1")]
    pub idle_timeout: ::core::option::Option<::prost_types::Duration>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Acknowledge {}
/// A list of subscribers
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Subscribers {
    #[prost(message, repeated, tag = "1")]
    pub subscribers: ::prost::alloc::vec::Vec<SubscriberIdentity>,
}
/// Sent to topic actor to add a subscriber
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeRequest {
    #[prost(message, optional, tag = "1")]
    pub subscriber: ::core::option::Option<SubscriberIdentity>,
}
/// Subscribe acknowledgement
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubscribeResponse {}
/// Sent to topic actor to remove a subscriber
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnsubscribeRequest {
    #[prost(message, optional, tag = "1")]
    pub subscriber: ::core::option::Option<SubscriberIdentity>,
}
/// Unsubscribe acknowledgement
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnsubscribeResponse {}
/// Message sent from publisher to topic actor
/// See also PubSubBatch
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PubSubBatchTransport {
    #[prost(string, repeated, tag = "1")]
    pub type_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2")]
    pub envelopes: ::prost::alloc::vec::Vec<PubSubEnvelope>,
}
/// Contains message byte representation and type reference
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PubSubEnvelope {
    #[prost(int32, tag = "1")]
    pub type_id: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub message_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(int32, tag = "3")]
    pub serializer_id: i32,
}
/// Message sent from topic to delivery actor
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeliverBatchRequestTransport {
    #[prost(message, optional, tag = "1")]
    pub subscribers: ::core::option::Option<Subscribers>,
    #[prost(message, optional, tag = "2")]
    pub batch: ::core::option::Option<PubSubBatchTransport>,
    #[prost(string, tag = "3")]
    pub topic: ::prost::alloc::string::String,
}
/// Message sent from delivery actor to topic to notify of subscribers that fail to process the messages
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyAboutFailingSubscribersRequest {
    #[prost(message, repeated, tag = "1")]
    pub invalid_deliveries: ::prost::alloc::vec::Vec<SubscriberDeliveryReport>,
}
/// Ack to the delivery actor after notification of subscribers that fail to process the messages
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NotifyAboutFailingSubscribersResponse {}
/// Contains information about a failed delivery
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscriberDeliveryReport {
    #[prost(message, optional, tag = "1")]
    pub subscriber: ::core::option::Option<SubscriberIdentity>,
    #[prost(enumeration = "DeliveryStatus", tag = "2")]
    pub status: i32,
}
/// Message posted to subscriber's mailbox, that is then unrolled to single messages, and has ability to auto respond
/// See also PubSubAutoRespondBatch
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PubSubAutoRespondBatchTransport {
    #[prost(string, repeated, tag = "1")]
    pub type_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2")]
    pub envelopes: ::prost::alloc::vec::Vec<PubSubEnvelope>,
}
/// Publish ack/nack response
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PublishResponse {
    /// Status of the whole published batch or single message
    #[prost(enumeration = "PublishStatus", tag = "1")]
    pub status: i32,
}
/// Delivery status as seen by the delivery actor
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeliveryStatus {
    /// Message was put in the queue of the subscriber
    Delivered = 0,
    /// Message did not reach subscriber, because it was dead
    SubscriberNoLongerReachable = 1,
    /// Delivery timed out
    Timeout = 2,
    /// Some other problem happened
    OtherError = 127,
}
impl DeliveryStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Delivered => "Delivered",
            Self::SubscriberNoLongerReachable => "SubscriberNoLongerReachable",
            Self::Timeout => "Timeout",
            Self::OtherError => "OtherError",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Delivered" => Some(Self::Delivered),
            "SubscriberNoLongerReachable" => Some(Self::SubscriberNoLongerReachable),
            "Timeout" => Some(Self::Timeout),
            "OtherError" => Some(Self::OtherError),
            _ => None,
        }
    }
}
/// Status of the whole published batch or single message
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PublishStatus {
    /// Batch or message was successfully published according to the delivery guarantees
    Ok = 0,
    /// Topic failed to forward the message
    Failed = 1,
}
impl PublishStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Ok => "Ok",
            Self::Failed => "Failed",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Ok" => Some(Self::Ok),
            "Failed" => Some(Self::Failed),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GossipRequest {
    #[prost(string, tag = "2")]
    pub from_member_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<GossipState>,
}
/// Ack a gossip request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GossipResponse {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<GossipState>,
}
/// string key is member id
/// GossipState is the state of that member
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GossipState {
    #[prost(map = "string, message", tag = "1")]
    pub members: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        GossipMemberState,
    >,
}
/// string key is the key of the gossip value, e.g. "heartbeat"
/// GossipKeyValue is the value of that key
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GossipMemberState {
    #[prost(map = "string, message", tag = "1")]
    pub values: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        GossipKeyValue,
    >,
}
/// a known key might be heartbeat. if we locally tag each entry with a local timestamp
/// this means that we can measure if we have not received a new heartbeat from one member in some time
/// even if we don't know the exact time the heartbeat was issued, due to clock differences.
/// we still know when _we_ as in this node, got this data.
/// and we can measure time from then til now.
///
/// if we got a hear-beat from another node, and X seconds pass, we can assume it to be dead
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GossipKeyValue {
    /// version is local to the owner member
    #[prost(int64, tag = "2")]
    pub sequence_number: i64,
    /// value is any format
    #[prost(message, optional, tag = "4")]
    pub value: ::core::option::Option<::prost_types::Any>,
    #[prost(int64, tag = "5")]
    pub local_timestamp_unix_milliseconds: i64,
}
/// special datatype that is known by gossip actor
/// set key
/// remove key
/// get keys
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GossipMap {
    #[prost(map = "string, message", tag = "1")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost_types::Any,
    >,
}
